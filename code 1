
# Import Libraries
import os
import cv2
import time
import pickle
import numpy as np
from datetime import datetime
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator, img_to_array, load_img
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelBinarizer
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import csv

# =======================
# Functions
# =======================

def preprocess_image(image, target_size=(100, 100)):
    """Convert image to RGB, resize, normalize"""
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, target_size)
    image = image.astype('float32') / 255.0
    return image

def load_data(data_dir, target_size=(100, 100)):
    """Load images and labels from folders"""
    X, y = [], []
    label_dict = {}
    label_counter = 0
    
    for label_name in os.listdir(data_dir):
        folder_path = os.path.join(data_dir, label_name)
        if not os.path.isdir(folder_path):
            continue
        if label_name not in label_dict:
            label_dict[label_name] = label_counter
            label_counter += 1
        for file in os.listdir(folder_path):
            if file.endswith(('.jpg', '.jpeg', '.png')):
                img_path = os.path.join(folder_path, file)
                img = cv2.imread(img_path)
                if img is None:
                    continue
                img = preprocess_image(img, target_size)
                X.append(img)
                y.append(label_dict[label_name])
    X = np.array(X)
    y = np.array(y)
    return X, y, label_dict

def create_cnn(input_shape, num_classes):
    """Create a simple CNN for face recognition"""
    model = Sequential([
        Conv2D(32, (3,3), activation='relu', input_shape=input_shape),
        MaxPooling2D(2,2),
        Conv2D(64, (3,3), activation='relu'),
        MaxPooling2D(2,2),
        Conv2D(128, (3,3), activation='relu'),
        MaxPooling2D(2,2),
        Flatten(),
        Dense(128, activation='relu'),
        Dropout(0.5),
        Dense(num_classes, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    return model

def train(data_dir, model_save_path, epochs=20, batch_size=32):
    """Train CNN on dataset"""
    X, y, label_dict = load_data(data_dir)
    if len(X) == 0:
        raise ValueError("No images loaded. Check your dataset path!")
    
    input_shape = X.shape[1:]
    num_classes = len(np.unique(y))
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # Data augmentation
    datagen = ImageDataGenerator(
        rotation_range=20,
        width_shift_range=0.2,
        height_shift_range=0.2,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True,
        fill_mode='nearest'
    )
    
    model = create_cnn(input_shape, num_classes)
    
    model.fit(datagen.flow(X_train, y_train, batch_size=batch_size),
              validation_data=(X_test, y_test),
              epochs=epochs)
    
    model.save(model_save_path)
    
    y_pred = np.argmax(model.predict(X_test), axis=1)
    
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred, average='weighted', zero_division=0)
    recall = recall_score(y_test, y_pred, average='weighted', zero_division=0)
    f1 = f1_score(y_test, y_pred, average='weighted', zero_division=0)
    
    return model, accuracy, precision, recall, f1, label_dict

def predict_faces(frame, model, label_dict, target_size=(100,100)):
    """Predict faces in a frame using CNN"""
    face_locations = face_recognition.face_locations(frame)
    inv_label_dict = {v:k for k,v in label_dict.items()}
    predictions = []
    
    for top, right, bottom, left in face_locations:
        face = frame[top:bottom, left:right]
        face_proc = preprocess_image(face, target_size)
        face_proc = np.expand_dims(face_proc, axis=0)
        pred = np.argmax(model.predict(face_proc), axis=1)[0]
        predictions.append((inv_label_dict[pred], top, right, bottom, left))
    return predictions

def log_attendance(name, log_file='attendance_log.csv'):
    time_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open(log_file, 'a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([name, time_str])
    print(f"Attendance recorded for: {name} at {time_str}")

# =======================
# Main
# =======================
def main():
    start_time = time.time()
    
    # Train the CNN model
    model_save_path = "classifier/cnn_face_model.h5"
    model, accuracy, precision, recall, f1, label_dict = train("train_img", model_save_path, epochs=15)
    
    end_time = time.time()
    print("Evaluation Metrics:")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1 Score: {f1:.4f}")
    print(f"Computational Time: {end_time - start_time:.2f} seconds")
    
    # Load trained model
    model = load_model(model_save_path)
    
    # Initialize webcam
    video_capture = cv2.VideoCapture(0)
    
    while True:
        ret, frame = video_capture.read()
        if not ret:
            break
        
        predictions = predict_faces(frame, model, label_dict)
        
        for name, top, right, bottom, left in predictions:
            cv2.rectangle(frame, (left, top), (right, bottom), (0,255,0), 2)
            cv2.putText(frame, name, (left, top-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0,255,0), 2)
            log_attendance(name)
        
        cv2.imshow('Face Recognition', frame)
        
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    
    video_capture.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
